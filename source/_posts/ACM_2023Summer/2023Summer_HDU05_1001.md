---
title: 题解|1001.Typhoon-2023暑期杭电多校05
date: 2023/8/1
updated: 2023/9/28
tags:
  - 2023暑期杭电多校
  - 计算几何
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: f4d5a717
description: 题解|1001.Typhoon-2023暑期杭电多校05 二维计算几何
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1001.Typhoon
**计算几何**
## 题目大意
依次给定 $n$ 个坐标 $P$ ，预测的台风路线为按顺序两两连接给定坐标所得的折线
现在有 $m$ 个庇护所的坐标 $S$ ，求每个庇护所到台风路线的最短距离
![Img](/images/ACM/2023Summer_HDU05_1001.jpg)
## 解题思路
对于每个庇护所坐标，求它到每个路线线段的距离，再取最短即可
常见的错误为计算了点到线段所在直线的距离，而非到线段的距离（~~别问我怎么知道的~~）

问题转移到如何计算点到线段的距离
可以考虑将线段表示为向量，记为 $vec$ ;点到线段两端的向量记为 $vec1,vec2$ 
如果 $vec1,vec2$ 与 $vec$ 的点积同时大于 $0$ 或同时小于 $0$ ，则距离在端点取到，否则距离为点到直线的距离//
具体说明可以参考代码注释

### 时间复杂度
 $O(nm)$

## 参考代码
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
vector<pll> typh,shel;
vector<double> frac,dist;
double cal_dist(pll s,pll t1,pll t2){//
    ll x,y,x1,y1,x2,y2,p1,p2;
    pll vec,vec1,vec2;double re;
    x=s.first;y=s.second;//庇护所坐标
    x1=t1.first;y1=t1.second;//端点1
    x2=t2.first;y2=t2.second;//端点2
    vec={x2-x1,y2-y1};vec1={x-x1,y-y1};vec2={x-x2,y-y2};
    //线段向量、点到两个端点的向量
    p1=vec.first*vec1.first+vec.second*vec1.second;//点积1
    p2=vec.first*vec2.first+vec.second*vec2.second;//点积2
    if(p1<=0&&p2>0||p1>0&&p2<=0){//点到直线距离
        double frac=(double)sqrt((y2-y1)*(y2-y1)+(x1-x2)*(x1-x2));
        re=(double)fabs((y2-y1)*x+(x1-x2)*y-y2*x1+x2*y1)/frac;
    }else{//点到端点距离
        double dist1=(double)sqrt(vec1.first*vec1.first+vec1.second*vec1.second);
        double dist2=(double)sqrt(vec2.first*vec2.first+vec2.second*vec2.second);
        re=min(dist1,dist2);
    }
    return re;
}
void solve()
{
    ll n,m;
    cin >> n >> m;
    typh.resize(n);shel.resize(m);dist.resize(m);
    for(auto &[x,y]:typh) cin >> x >> y;
    for(auto &[x,y]:shel) cin >> x >> y;
    FORLL(i,0,m-1){dist[i]=INF;
        FORLL(j,0,n-2)
            dist[i]=min(dist[i],cal_dist(shel[i],typh[j],typh[j+1]));}
    for(double i:dist) {print_float(i,4);cout << endl;}
}
```

