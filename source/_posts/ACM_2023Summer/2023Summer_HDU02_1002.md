---
title: 题解|1002.Binary Number-2023暑期杭电多校02
date: 2023/7/20
updated: 2023/9/27
tags:
  - 2023暑期杭电多校
  - 字符串
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: 60278ece
description: 题解|1002.Binary Number-2023暑期杭电多校02 字符串·贪心
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1002.Binary Number
**字符串、贪心**
## 题目大意
给定一段长度为$n$的01串，首位保证为1
任选定其中任意长的一段并将其反转
必须执行以上操作$k$次，求操作后得到的01串表示的二进制数最大的状态并输出
## 解题思路
首先考虑**次数不足**的情况。对于一个二进制数，高位的权重大于其所有低位权重之和。因此优先考虑将靠前的字符中的0反转为1。

接下来比较多次反转**不同方案**的优劣。忽略操作次数限制，考虑这个字符串：1001001001
1. 最直观的办法是直接选定第2-3,5-6,8-9位反转为1，得到全1串。
2. 还有一种可选的优质方法:1001001001 $\Rightarrow$ 1110110111 $\Rightarrow$ 11100111 $\Rightarrow$ 1111111111

上述两种方法对于同样3段的0，次数相同，并且第一种方法更便于考虑，故采取第一种策略，从左往右反转0。

接下来再考虑已经转化为全1串，**次数溢出**的情况。可以考虑在转换过程中做无效操作浪费次数，避免对最大结果造成影响。

1. 对于起始01串，如果有0必有前导1(首位保证为1)。因此可以在反转某段0时带上前导1一起，再消耗1次操作单独转回前导1，可以浪费1次数
2. 对于单个1做2次反转操作，可以浪费2次数
3. 对于连续的2个1，分两次单独反转这两个1，然后一起翻回，可以浪费3次数

在以上策略的搭配下，正常情况下可以消耗任意溢出次数，并最终状态为全1

最后考虑**特殊情况**
1. 当起始01串全为1，且$k=1$，此时只能反转末位1使损失最小
2. 当01串长度为1，此时起始01串只能是"1"，其状态只由$k$的奇偶决定

(P.S.)谁赛时程序中把'='写成"=="又不想Remake于是卡签一个半小时我不说

### 时间复杂度
$O(n)$

## 参考程序
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
int solve()
{
    string s,re;
    ll n,k;
    cin >> n >> k;
    cin >> s;
    s.push_back(0);
    ll flag=0,all1=1;
    FORLL(i,0,n-1){
        if(s[i]=='0'){
            if(flag==0&&k) {k--;flag=1;}
            if(flag) re.push_back('1');
            else re.push_back('0');
            all1=0;
        }
        else{
            re.push_back('1');
            flag=0;
        }
    }
    if(k==1&&all1) re[n-1]='0';
    if((k%2)&&n==1) re[0]='0';
    cout << re << endl;
    return 0;
}
```