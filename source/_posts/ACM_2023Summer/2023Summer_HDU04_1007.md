---
title: 题解|1007.Guess-2023暑期杭电多校04
date: 2023/7/27
updated: 2023/9/27
tags:
  - 2023暑期杭电多校
  - 数学
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: 7beaedb9
description: 题解|1007.Guess-2023暑期杭电多校04 莫比乌斯函数
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1007.Guess
**莫比乌斯函数**
## 题目大意
给定一个正整数 $n\le1e18$ ，求 $e^{S(n)}$ 

其中，$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)$ ，$e$ 是自然对数 $\ln$ 的底数，$\mu(x)$ 是莫比乌斯函数，答案取模

### 前置知识点
[莫比乌斯函数](https://baike.baidu.com/item/%E9%BB%98%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/16625781)：
$$
\mu(n)=\begin{cases}
    1 &,n=1; \newline
    0 &,n含有大于1的完全平方因子; \newline
    (-1)^k &,n为k个质数的乘积 \newline
\end{cases}
$$

## 解题思路
对于 $n$ 的因数 $d$ ，根据 $\dfrac{n}{d}$ 与 $d$ 的轮换对称性可知：
$S(n)=\sum\limits_{d|n} \mu(\dfrac{n}{d})\ln(d)=\sum\limits_{d|n} \mu(d)\ln(\dfrac{n}{d})$

对 $S(n)$ 做一次莫比乌斯变换（第一形式）可得：$\ln(n)=\sum\limits_{d|n} S(d)$

两边以 $e$ 做底数得 $e^{ln(n)}={e}^{\sum\limits_{d|n} S(d)}\Rightarrow n=\prod\limits_{d|n} e^{S(d)}$ 

右式是一个连乘积，其连乘长度为 $n$ 的全体因数个数
记 $F(x)=e^{S(x)}$ ，那么答案也就是在求 $F(n)$ 

根据上式：
1. $1=F(1)\Rightarrow F(1)=1$
2. 对于任意质数 $x$ ，$x=F(1)F(x)\Rightarrow F(x)=x$
3. 对于任意合数 $x$ ，借助 $1,2$ 递归计算出 $F(x)$ 

经过较长时间的感性理解，想到了一种遍历求 $F(x)$ 方法的伪代码如下：

```
F[]={0}
FOR i in {1..+∞}
    FOR p in Primes
        if F[i*p]==0 then F[i*p]=p
```
（其实打表也挺好的，想个一般性的方法好难qwq）

可以得到以下 $F(x)$ 的正整数序列：
$1,2,3,2,5,1,7,2,3,1,11,1,13,1,1,2,17,1,19,1,1,1,23\cdots$

这个序列的意义是 $x$ 对乘积 $n$ 的贡献，回到上面看那个连乘积的长度和表达形式就非常合理了

通项公式为：
$$\begin{align}
    F(n)&=lcm\{1..n\}/lcm\{1..n-1\} \newline
    &=\begin{cases}
        n&,n=p^i,p是素数,i\in \N_+ \newline
        1&,Otherwise
    \end{cases}
\end{align}
$$ 
即为最终答案

面对 $n\le 1e18$ 的庞大数据，问题就落到了如何快速求出 $F(n)$ 上了。根据通项公式，只需要判断 $n$ 是否有且只有一个素数非平凡因子 $p$ 即可

Pollard-Rho算法是一种用于因数分解整数的快速随机算法，它可以实现在 $n^{\frac{1}{4}}$ 的时间下随机找到一个 $n$ 的非平凡因子
其中用到了Miller-Rabin 素性测试算法，是一种测试素数的快速随机算法

Pollard-Rho算法的具体实现可以参考这篇博文：[大数因数分解Pollard_rho 算法详解](https://blog.csdn.net/maxichu/article/details/45459533)

最终根据查找结果，结合通项公式判断输出即可

## 参考代码
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

（Pollard_Rho算法及Miller_Rabin算法部分略）
```cpp
ll fac=0;
bool prop(ll n){//判断n==p^i
    if(n==1) return true;
    if(Miller_Rabin(n)){
        if(fac==0) fac=n;
        else if(fac!=n) return false;
        return true;
    }
    ll p=n;
    while(p==n) p=Pollard_Rho(n);
    if(prop(p)&&prop(n/p)) return true;
    return false;
}
void solve()
{
    srand(time(0));
    fac=0;
    ll n;cin >> n;
    if(n==1) {cout << 1 << ' ';return;}
    if(Miller_Rabin(n)) {cout << Get_Mod(n) << ' ';return;}
    if(prop(n)) cout << Get_Mod(fac) << ' ';
    else cout << 1 << ' ';
}
```
![Alt text](image-3.png)