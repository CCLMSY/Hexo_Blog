---
title: 题解|1005.0 vs 1-2023暑期杭电多校08
date: 2023/8/10
updated: 2023/9/28
tags:
  - 2023暑期杭电多校
  - 博弈
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: a4f57cd6
description: 题解|1005.0 vs 1-2023暑期杭电多校08 博弈
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1005.0 vs 1
**博弈，模拟**
## 题目大意
两人名为零和壹，在给定的 $01$ 串上进行博弈
零只能取走两端的某一个 $0$ ，壹只能取走两端的某一个 $1$ ，零执先
先不能取的人判负，若取完则判平局

## 解题思路
模拟博弈过程，当前操作者 $x$ 可以可以遵循以下策略：
1. 两端不同，只能取 $x$ 的一端，交替操作权
2. 两端相同
   1. 两端都不是 $x$ ，无法操作，失败
   2. 两端都是 $x$ ，假设取了某端
      1. 这端的下一个数字是 $x$ ，则两端都是 $x$ ，对方无法操作，获胜
      2. 这端的下一个数字是 $!x$ ，则对方只能取这一端
   3. 如果离任一端最近的连续两个相同的数都为 $x$ ，则根据上 $2$ 一直取到 $x$ 获胜
   4. 如果离两端最近的连续两个相同的数都为 $!x$ ，则不论选哪端，最终都会到达两端都为 $!x$ 的情况，失败
      1. 特判：如果整个串有且仅有 $1$ 段连续两个相同的 $!x$ ，则从两端向中间将各会取掉一个，达成平局 

可以结合代码注释理解这一过程
### 时间复杂度
$O(n)$

## 参考代码
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
void solve_s(deque<int> s,int now){
    ll n=s.size(),i,j;;
    if(s.empty()) {cout << "-1" << endl;return ;}//取完平局
    if(s.front()!=s.back()){//前后不同，无法自由选择，交替操作权
        if(s.front()==now){//取前
            s.pop_front();solve_s(s,(now?0:1));return ;
        }else{//取后
            s.pop_back(); solve_s(s,(now?0:1));return ;
        }
    }else{//前后相同
        if(s.front()!=now) {cout << (now?"0":"1") << endl;return ;}//两端不可取，失败
        for(i=0;i<n-1;i++) if(s[i]==s[i+1]) break;//从前往后找第一个连续
        if(i==n-1) {cout << "-1" << endl;return ;}//无连续，取完平局
        if(s[i]==now) {cout << (now?"1":"0") << endl;return ;}//有己方连续，胜利
        for(j=n-1;j>i;j--) if(s[j]==s[j-1]) break;//从后往前找最后一个连续
        if(s[j]==now) {cout << (now?"1":"0") << endl;return ;}//有己方连续，胜利
        if(i+1==j) {cout << "-1" << endl;return ;}//有且仅有一对对方连续，取完平局
        {cout << (now?"0":"1") << endl;return ;}//两对以上对方连续，失去主动权，判负
    }
}
void solve(){
    ll n;cin >> n;
    string ts;cin >> ts;
    deque<int> s(n);FORLL(i,0,n-1) s[i]=ts[i]-'0';
    solve_s(s,0);
}
```