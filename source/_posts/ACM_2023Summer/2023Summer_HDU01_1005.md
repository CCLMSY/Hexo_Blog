---
title: 题解|1005.Cyclically Isomorphic-2023暑期杭电多校01
date: 2023/7/18
updated: 2023/9/27
tags:
  - 2023暑期杭电多校
  - 字符串
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: aa260843
description: 题解|1005.Cyclically Isomorphic-2023暑期杭电多校01 字符串匹配
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1005.Cyclically Isomorphic

**字符串匹配**

## 题目大意
对于两个字符串 $s_1$ , $s_2$ ，如果存在一个整数 $k$ 使得 $s_1$ 循环右移k位与 $s_2$ 相同，则称他们是"cyclically right-shifted"。
每组数据给出 $n$ 个长度为 $m$ 的字符串， $Q$ 次询问两个字符串是否"cyclically right-shifted"。

## 解题思路
对于每一字符串，找到其字典序最小的状态储存，每次询问时直接比较即可。
主要是时间复杂度难以证明

### 时间复杂度
找最小态储存 $n \times m^2$ ，比较 $Q \times m$
 $Q \le \dfrac{1}{2} n(n-1) \Rightarrow$ 比较 $m \times n^2$  
总复杂度： $O(mn \times (m+n))$ ， 
 $mn \le 10^5$ 下~~数据不变态的话~~就能卡过去

## 参考程序
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
int solve()
{
    string s[N],s1,s2;
    char t;
    ll n,m;
    cin >> n >> m;
    FORLL(i,1,n)
    {
        cin >> s1;
        s2=s1;
        FORLL(j,1,m)
        {
            t=s2.front();
            s2.erase(s2.begin());
            s2.push_back(t);
            if(s1.compare(s2)>0) s1=s2;
        }
        s[i]=s1;
    }
    ll Q;cin >> Q;
    while(Q--)
    {
        cin >> n >> m;
        if(s[n].compare(s[m])==0) cout << YES;
        else cout << NO;
    }
    return 0;
}
```