---
title: 题解|1003.Simple Set Problem-2023暑期杭电多校04
date: 2023/7/27
updated: 2023/9/27
tags:
  - 2023暑期杭电多校
  - 思维
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: 803f0ea0
description: 题解|1003.Simple Set Problem-2023暑期杭电多校04 思维
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1003.Simple Set Problem
**思维**
## 题目大意
给定 $k$ 个非空集合，在每一个集合里选择一个数 $a_i$ ，使得这些数之中最大值与最小值之差 $d=max(a_i)-min(a_i)$ 最小，输出 $d$ 的最小值
## 解题思路
不论哪一种选法，最小值一定是在全体元素中取到的
不妨从小到大遍历全体元素作为下界，记当前遍历元素为 $a_i$ 
在每一个集合中二分查找恰好大于等于 $a_i$ 的元素选入(遍历到 $a_i$ 所在集合的时候，一定会选入 $a_i$ )
找到选定元素的最大值，做差
直到某个集合中没有大于等于 $a_i$ 的元素为止（此时该集合最大的元素选入的情况已全部考虑过），最终在得到的值中取最小即可
### 时间复杂度
读入： $O(n)$ ；排序： $O(n\log n)$ ；遍历二分查找： $O(n\log n)$ 
综合时间复杂度：  $O(n\log n)$ 
其中 $n$ 表示全体元素个数， $n\le 4e6$

## 参考代码
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
void solve()
{
    ll n;
    cin >> n;
    vector<vector<ll>> sets(n+1);
    vector<ll> v;
    vector<ll>::iterator it;
    ll tn,t;
    FORLL(i,1,n){
        cin >> tn;
        FORLL(j,1,tn) {cin >> t;sets[i].emplace_back(t);v.emplace_back(t);}
        SORT(sets[i]);
    }SORT(v);
    ll re=INF,tre;
    for(auto x:v){
        tre=0;
        FORLL(i,1,n){
            it=lower_bound(ALL(sets[i]),x);
            if(it==sets[i].end()) {tre=-1;break;}
            tre=max(tre,*it-x);
        }
        if(tre==-1) break;
        re=min(re,tre);
    }
    cout << re << endl;
}
```