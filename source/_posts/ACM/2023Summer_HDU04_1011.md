---
title: 题解|1011.Circuit-2023暑期杭电多校04
date: 2023/7/27
updated: 2023/9/27
tags:
  - 2023暑期杭电多校
  - 图论
  - 计数
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: 3718ba95
description: 题解|1011.Circuit-2023暑期杭电多校04 最短路/Floyd算法·计数
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1011.Circuit
**图论-最短路-Floyd**
## 题目大意
给定一个无重边、无自循环的带权有向图 $G=(V,E),|V|=n,|E|=m$ 
求 $G$ 的所有回路中最短回路的长度以及个数，个数取模

## 解题思路
全图范围的最短路计数，考虑使用弗洛伊德算法//

为了不重不漏的计数，考虑每个最短回路仅在其最大标号处计数
对于一条有向回路，可以将其最大编号到下一点的有向边单独分割出来，剩余部分即为从起点到回路上最大编号点的最短路//

借助Floyd算法，在 $O(n^3)$ 的时间内，计算最短路的同时，可以进行最短路方案数的计数，这里详细阐述一下计数过程

原图 $G$ 存在有向边 $u\rightarrow v$ ，则 $u\rightarrow v$ 的初始方案数置为 $1$ ，没有边则置为 $0$

加入点 $k$ 时，过点 $k$ 的 $i\rightarrow j$ 的最短路的方案数为： $i\rightarrow k$ 的最短方案数 $\times$ $k\rightarrow j$ 的最短路方案数
如果发生最短路更新，则方案数一并更新//另判断如果长度一致，则方案数需相加

每次完成更新后，假设 $k$ 已经是以 $i$ 为起点的最短回路上的最大编号点了，此时原图 $G$ 中如果有 $k\rightarrow i$ 的有向边，则可以构成回路，比较计数即可//

更加具体的内容可以参考代码注释

温馨提示： $INF$ 的值需要设置到 $1e18$ ，因为两段方案数乘积最大可以为 $MOD^2 \approx 1e18$ ，补题时因为 $INF$ 的值不够大卡了两个小时左右

### 时间复杂度
Floyd算法：$O(n^3)$

## 参考代码
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
const long long INF=1e18;
#define N 505
ll dist[N][N]={0},cnt[N][N]={0},ori[N][N]={0};
ll mindist=INF,cntmin=0;
void RESET_G(ll n){
    FORLL(i,1,n)
        FORLL(j,1,n){
        ori[i][j]=0;
        dist[i][j]=(i==j?0:INF);
        cnt[i][j]=0;
        }
    mindist=INF,cntmin=0;
}//重置
void Floyd(ll n){
    FORLL(k,1,n)
        FORLL(i,1,n){
            FORLL(j,1,n){//Floyd
                if(dist[i][j]>dist[i][k]+dist[k][j]){
                    dist[i][j]=dist[i][k]+dist[k][j];
                    cnt[i][j]=mul(cnt[i][k],cnt[k][j]);//cnt[i][j]=cnt[i][k]*cnt[k][j]
                    //方案数为两段方案数的乘积，更新同步
                }else if(dist[i][j]==dist[i][k]+dist[k][j]){
                    addto(cnt[i][j],mul(cnt[i][k],cnt[k][j]));//cnt[i][j]+=cnt[i][k]*cnt[k][j]
                    //相等则方案数相加
                }
            }
            if(i<k&&ori[k][i]){//假设到k为以i为起点的单向环上最大点
                if(ori[k][i]+dist[i][k]<mindist) {mindist=ori[k][i]+dist[i][k];cntmin=cnt[i][k];}
                else if(ori[k][i]+dist[i][k]==mindist) addto(cntmin,cnt[i][k]);//cntmin+=cnt[i][k]
        }
    }
}
void solve()
{
    ll n,m;
    cin >> n >> m;
    RESET_G(n);
    ll u,v,w;
    FORLL(i,1,m){
        cin >> u >> v >> w;
        ori[u][v]=w;
        dist[u][v]=w;
        cnt[u][v]=1;
    }
    Floyd(n);
    if(cntmin) cout << mindist << ' ' << cntmin << endl;
    else cout << "-1 -1" << endl;
}
```