---
title: 题解|1013.Minimal and Maximal XOR Sum-2023暑期杭电多校07
date: 2023/8/8
updated: 2023/9/28
tags:
  - 2023暑期杭电多校
  - 贪心
categories: 算法竞赛
keywords:
top_img: false
comments: true
cover:
toc: true
abbrlink: 2a369854
description:  题解|1013.Minimal and Maximal XOR Sum-2023暑期杭电多校07 归并排序·贪心
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
highlight_shrink:
aside:
---

# 1013.Minimal and Maximal XOR Sum
**归并排序、贪心**
## 题目大意
给定一个长度为 $n$ 的排列 $p$ ，每次操作可以选定一段连续子序列 $p_{i,j}$ ，花费等同于元素个数的代价 $c=j-i+1$ ，使得这一段顺序反转
记使得排序变成自然排序（ $p_i=i$ ）所经过的一系列操作中，每一次的代价的异或和为 $x=c_1 \oplus c_2 \oplus \cdots \oplus c_i$
求 $x$ 的最大值和最小值

## 解题思路
排列的奇偶性定义为其所具有的逆序对数的奇偶性。任意一个n阶排列，可经过一系列对换转变为标准排列，且所做对换的次数与排列具有相同的奇偶性。

观察操作的特点可以得出，选定单一元素操作时，排列本身不发生改变，但产生 $1$ 点代价//这意味着所得结果 $x$ 的最后一个二进制位可以任意调整（和 $1$ 做异或）

考虑使得 $x$ 最小的操作方法
每次花费 $2$ 代价做对换，最小值 $x_{min}$ 一定会落在 $0$ 或 $2$ 上。根据对换次数与排列奇偶性的关系，判断排列逆序对数的奇偶性即可，可以使用归并排序进行逆序对计数

接下来考虑使得 $x$ 最大的操作方法
在排列 $p$ 已经有序的情况下，考虑如何操作花费代价可以使得异或和 $x$ 产生高位 $1$ ：先花费高代价 $c$ 反转某个长子序列，再连续花费 $2$ 代价做对换将序列恢复为有序

可以发现 $x$ 的最大可能二进制位数与 $n$ 相同，逐位考虑转 $1$ 记某位上的权重为 $2^m <n$ ，则反转 $2^m$ 个数后，恢复有序需要连续做对换的次数为 $2^m(2^m-1)/2$ ， $m\ge 2$ 时对换次数为偶数，即对最终的异或和 $x$ 无影响，这意味着按照上述策略可以将 $x$ 倒数第3位（权重为4）及以前的数位全部置1//

$m=1$ 时对换次数为 $1$ ，和反转 $2^1$ 个数的代价 $2$ 抵消，因此无法变更倒数第二位的值

综上所述，只需将 $x$ 调整为与 $n$ 具有相同二进制数的最大值，再判断倒数第二位即可//

 
### 时间复杂度
归并排序： $O(n\log n)$

## 参考代码
> 参考代码为已AC代码主干，其中部分功能需读者自行实现

```cpp
void solve()
{
    ll n;cin >> n;ll mn,mx;
    vector<ll> v(n);
    for(auto &x:v) cin >> x;
    ll cntinv=mergeSortAndCount(v,0,n-1);
    if(cntinv%2) mn=2;else mn=0;
    ll t=n,dig=0;while(t) {dig++;t/=2;}
    mx=(1<<dig)-1;
    if(mn==0) mx-=2;
    if(n==1) cout << "0 1" << endl;
    else cout << mn << ' ' << mx << endl;
}
```